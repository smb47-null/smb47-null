class BrainfuckInterpreter:     def init(self):         """Initialize the Brainfuck interpreter with default settings"""         self.memory = [0] * 30000  # Standard memory size         self.pointer = 0         self.instruction_pointer = 0         self.output_callback = None         self.input_callback = None         self.execution_paused = False         self.execution_complete = False         self.debug_mode = False              def set_callbacks(self, output_callback=None, input_callback=None):         """Set callbacks for input/output operations"""         self.output_callback = output_callback         self.input_callback = input_callback              def reset(self):         """Reset the interpreter state"""         self.memory = [0] * 30000         self.pointer = 0         self.instruction_pointer = 0         self.execution_paused = False         self.execution_complete = False              def toggle_debug(self):         """Toggle debug mode"""         self.debug_mode = not self.debug_mode         return self.debug_mode              def get_memory_state(self, window_size=10):         """Return the current memory state around the pointer for visualization"""         start = max(0, self.pointer - window_size // 2)         end = min(len(self.memory), start + window_size)         return {             'memory': self.memory[start:end],             'start_index': start,             'pointer_relative': self.pointer - start         }              def execute(self, code, step_by_step=False):         """Execute Brainfuck code"""         # Filter valid commands         code = ''.join(c for c in code if c in '><+-.,[]')         output = []         brackets_stack = []         bracket_map = {}                  # Pre-compute bracket pairs         for i, char in enumerate(code):             if char == '[':                 brackets_stack.append(i)             elif char == ']':                 if brackets_stack:                     start = brackets_stack.pop()                     bracket_map[start] = i                     bracket_map[i] = start                  # Execute the code         self.execution_complete = False         self.execution_paused = False                  while (self.instruction_pointer < len(code) and                 not self.execution_paused and                 not self.execution_complete):                          command = code[self.instruction_pointer]                          if self.debug_mode:                 debug_info = {                     'cmd': command,                     'pos': self.instruction_pointer,                     'ptr': self.pointer,                     'current_value': self.memory[self.pointer]                 }                 if self.output_callback:                     self.output_callback(f"Debug: {debug_info}", is_debug=True)                          if command == '>':                 self.pointer = (self.pointer + 1) % 30000             elif command == '<':                 self.pointer = (self.pointer - 1) % 30000             elif command == '+':                 self.memory[self.pointer] = (self.memory[self.pointer] + 1) % 256             elif command == '-':                 self.memory[self.pointer] = (self.memory[self.pointer] - 1) % 256             elif command == '.':                 char = chr(self.memory[self.pointer])                 output.append(char)                 if self.output_callback:                     self.output_callback(char)             elif command == ',':                 if self.input_callback:                     input_char = self.input_callback()                     if input_char:                         self.memory[self.pointer] = ord(input_char[0])                 else:                     # Default behavior without input callback                     self.memory[self.pointer] = ord('?')             elif command == '[' and self.memory[self.pointer] == 0:                 self.instruction_pointer = bracket_map.get(self.instruction_pointer, self.instruction_pointer)             elif command == ']' and self.memory[self.pointer] != 0:                 self.instruction_pointer = bracket_map.get(self.instruction_pointer, self.instruction_pointer)                              self.instruction_pointer += 1                          if step_by_step:                 self.execution_paused = True                 break                          if self.instruction_pointer >= len(code):             self.execution_complete = True                      return ''.join(output)          def continue_execution(self, code, step_count=1):         """Continue execution from where it was paused"""         if self.execution_complete:             return ""                      step_by_step = step_count == 1         result = ""                  for _ in range(step_count):             if not self.execution_paused or self.execution_complete:                 break                              self.execution_paused = False             result += self.execute(code, step_by_step)                      return result   # Integration with the app class AppIntegration:     def init(self):         self.interpreter = BrainfuckInterpreter()         self.current_code = ""         self.input_buffer = []         self.output_history = []              def initialize(self):         """Initialize the interpreter with app callbacks"""         self.interpreter.set_callbacks(             output_callback=self.handle_output,             input_callback=self.handle_input         )              def handle_output(self, char, is_debug=False):         """Handle output from the interpreter"""         if is_debug:             # Handle debug information differently if needed             self.output_history.append({"type": "debug", "content": char})         else:             self.output_history.append({"type": "output", "content": char})                  # Call UI update here if needed         # self.update_ui()              def handle_input(self):         """Provide input to the interpreter"""         if self.input_buffer:             return self.input_buffer.pop(0)         # Could trigger UI input request here         return '?'              def set_input(self, input_text):         """Set input to be used by the interpreter"""         self.input_buffer.extend(list(input_text))              def run_code(self, code, mode="full"):         """Run code with the specified mode"""         self.current_code = code         self.output_history = []         self.interpreter.reset()                  if mode == "full":             result = self.interpreter.execute(code)             return result         elif mode == "step":             return self.interpreter.execute(code, step_by_step=True)         elif mode == "debug":             self.interpreter.toggle_debug()             return self.interpreter.execute(code, step_by_step=True)                  def continue_execution(self, steps=1):         """Continue execution for the specified number of steps"""         return self.interpreter.continue_execution(self.current_code, steps)              def get_memory_visualization(self):         """Get memory state for visualization"""         return self.interpreter.get_memory_state(20)              def get_output_history(self):         """Get the output history"""         return self.output_history   # Example usage: if name == "main":     # This demonstrates how to use the integrated interpreter     app = AppIntegration()     app.initialize()          # Hello World program in Brainfuck     hello_world = """     ++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.     """          # Run the code     result = app.run_code(hello_world)     print(f"Result: {result}")          # Get memory visualization     memory_state = app.get_memory_visualization()     print(f"Memory state: {memory_state}")          # Reset and run step by step     app.run_code(hello_world, mode="step")     while not app.interpreter.execution_complete:         app.continue_execution(1)         # This would normally update the UI between steps         print(f"Pointer: {app.interpreter.pointer}, Value: {app.interpreter.memory[app.interpreter.pointer]}")



